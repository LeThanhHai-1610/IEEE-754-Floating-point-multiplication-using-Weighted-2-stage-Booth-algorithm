---------------------------------------------------------
--  This code is generated by Terasic System Builder
---------------------------------------------------------


library ieee;
use ieee.std_logic_1164.all;
use ieee.NUMERIC_STD.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_signed.all;
use ieee.std_logic_misc.or_reduce;
use ieee.std_logic_misc.and_reduce;
entity Capstone_v5 is
port
(
	x,y         :   in      std_logic_vector(31 downto 0);
	sign        :   out std_logic;
	overflow    :   buffer std_logic;
	underflow   :   buffer std_logic;
	exponential :   buffer    std_logic_vector(7 downto 0);
	mantisa     :   out      std_logic_vector(22 downto 0);
	------------ CLOCK ------------
	CLOCK_50        	:in    	std_logic
);

end entity;

---------------------------------------------------------
--  Structural coding
---------------------------------------------------------


architecture rtl of Capstone_v5 is
-- declare --
signal xb1,x11,y11         :      std_logic_vector(27 downto 0);
signal c1		   	      :		 std_logic_vector(28 downto 0);
signal a,b,c,d,e,f,g       :    	 std_logic_vector(51 downto 0);
signal a0,b0,c0,d0,e0,f0,g0              :    	 std_logic_vector(30 downto 0);
signal cr0,cr1,cr2,cr3,cr4,cr5           :       std_logic;
signal S0,S1,S2,S3,S4,S5   :  STD_LOGIC_VECTOR (51 downto 0);
signal result              :  STD_LOGIC_VECTOR (46 downto 0);
signal e1,e2,e3            :  STD_LOGIC_VECTOR (8 downto 0) ;
signal exponential1, temp_exponential1   :   std_logic_vector(8 downto 0);
signal exponential2                      :   std_logic_vector(7 downto 0);
signal carry1,carry2 :  std_logic_vector(9 downto 0);
signal overflow1,underflow1,zero,and1,and2,and3,or1,or2,or3      :       std_logic;
signal mantisa1,x111 :  std_logic_vector(22 downto 0);
component Booth_decoder is
Port ( c : in STD_LOGIC_VECTOR(4 DOWNTO 0) ;
h : buffer STD_LOGIC_VECTOR(30 DOWNTO 0)   ;
x1,xb : in STD_LOGIC_VECTOR(27 DOWNTO 0))  ;
end component;

component Adder is
port
(
   x : in STD_LOGIC_VECTOR (51 downto 0);
   y : in STD_LOGIC_VECTOR (51 downto 0);
   Cin : in STD_LOGIC;
   S : out STD_LOGIC_VECTOR (51 downto 0);
   Cout : out STD_LOGIC
);
end component;

component RCA is
Port ( in1,in2 : in STD_LOGIC_VECTOR(8 DOWNTO 0) ;
out1 : buffer STD_LOGIC_VECTOR(8 DOWNTO 0) );
end component ;

begin

zero <= or_reduce(y(30 downto 0))  ; -- check whether multiplier is 0
and1 <= and_reduce(x(30 downto 23)); -- check whether E1 is 11111111
and2 <= and_reduce(y(30 downto 23)); -- check whether E2 is 11111111
or1 <= or_reduce(x(30 downto 23))  ; -- check whether E1 is 00000000
or2 <= or_reduce(y(30 downto 23))  ; -- check whether E2 is 00000000

-- body --

-- Mantissa multiplication pre-processing --
process(y)
begin
if zero = '0' then x11 <= "00000" & y(22 downto 0); y11 <= "00001" & y(22 downto 0);
else x11 <= "00001" & x(22 downto 0); y11<= "00001" & y(22 downto 0);
end if;
end process;

c1 <= y11 & '0'; xb1 <= not(x11) + '1';
sign <= x(31) xor y(31);

-- Exponent pre-processing --
process (x,y)
begin
if (and1 or and2) = '1' then e1 <= "011111111"; e2 <= "011111111";
elsif (zero = '0' or or1 = '0' or or2 = '0') then e1 <= "000000000"; e2 <= "000000000";
else
e1 <= '0' & x(30 downto 23);
e2 <= '0' & y(30 downto 23);
end if;
end process;
e3 <= "110000001"; -- (-127)


-- Exponent calculator --
Adder1: RCA port map(e1,e2,temp_exponential1);
process(temp_exponential1)
begin
if (temp_exponential1(8 downto 7) = "00") -- underflow condition 
	then underflow1 <= '1';
else underflow1 <= '0';
end if;
end process;
Adder2: RCA port map(temp_exponential1,e3,exponential1);

-- Mantissa multiplication --
Booth_decoder1: Booth_decoder PORT MAP (c1(4 downto 0),a0,x11,xb1);
Booth_decoder2: Booth_decoder PORT MAP (c1(8 downto 4),b0,x11,xb1);
Booth_decoder3: Booth_decoder PORT MAP (c1(12 downto 8),c0,x11,xb1);
Booth_decoder4: Booth_decoder PORT MAP (c1(16 downto 12),d0,x11,xb1);
Booth_decoder5: Booth_decoder PORT MAP (c1(20 downto 16),e0,x11,xb1);
Booth_decoder6: Booth_decoder PORT MAP (c1(24 downto 20),f0,x11,xb1);

process(a0,b0,c0,d0,e0,f0)
begin

if (a0 (30) = '1') then a <= "111111111111111111111" & a0;
else a <=                    "000000000000000000000" & a0; end if;

if (b0 (30) = '1') then b <= "11111111111111111" & b0 & "0000";
else b <=                    "00000000000000000" & b0 & "0000"; end if;

if (c0 (30) = '1') then c <= "1111111111111" & c0 & "00000000";
else c <=                    "0000000000000" & c0 & "00000000"; end if;

if (d0 (30) = '1') then d <= "111111111" & d0 & "000000000000";
else d <=                    "000000000" & d0 & "000000000000"; end if;
 
if (e0 (30) = '1') then e <= "11111" & e0 & "0000000000000000";
else e <=                    "00000" & e0 & "0000000000000000"; end if;

if (f0 (30) = '1') then f <= "1" & f0 & "00000000000000000000";
else f <= "0" & f0 & "00000000000000000000"; end if;

g <=  x11 & "000000000000000000000000";

end process;

-- CLAs --
A1: Adder port map (a,b,'0',S0,cr0);
A2: Adder port map (c,d,'0',S1,cr1);
A3: Adder port map (e,f,'0',S2,cr2);
A4: Adder port map (S0,S1,'0',S3,cr3);
A5: Adder port map (S2,g,'0',S4,cr4);
A6: Adder port map (S3,S4,'0',S5,cr5);
--
result <= S5(46 downto 0);

-- Normalization unit --
process(cr5,exponential1,exponential)
begin

	if (S5(47) = '1') then
	    if (exponential1(8) = '1') then 
	        if (underflow1 = '1') then overflow1 <= '0'; exponential2 <= "00000000"; mantisa1 <= "00000000000000000000000";
	        else overflow1 <= '1';exponential2 <= "11111111"; mantisa1 <= "00000000000000000000000"; 
		     end if;
		 else overflow1 <= '0'; exponential2 <= exponential1(7 downto 0) + '1'; mantisa1 <= result(46 downto 24);
		 end if;

	else 
	    if (exponential1(8) = '1') then 
	        if (underflow1 = '1') then overflow1 <= '0'; exponential2 <= "00000000"; mantisa1 <= "00000000000000000000000";
	        else overflow1 <= '1';exponential2 <= "11111111"; mantisa1 <= "00000000000000000000000";--; 
		     end if;
		 else overflow1 <= '0'; exponential2 <= exponential1(7 downto 0); mantisa1 <= result(45 downto 23); 
		 end if;
	end if;
end process;
and3 <= and_reduce(exponential2);
or3 <= or_reduce(exponential2);

-- Check overflow/underflow --
process(exponential2)
begin
   if and3 = '1' then overflow <= '1';underflow <= '0'; exponential <= "11111111"; mantisa <= "00000000000000000000000";
	elsif (or3 = '0') then underflow <= '1';overflow <= '0'; exponential <= "00000000"; mantisa <= "00000000000000000000000";
	else overflow <= overflow1; underflow <= underflow1; exponential <= exponential2; mantisa <= mantisa1;
	end if;
end process;
end rtl;
--------------------------------------------
-- Weighted 2-stage Booth algorithm --
library ieee;
use ieee.std_logic_1164.all;
use ieee.NUMERIC_STD.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_signed.all;
entity Booth_decoder is
Port ( c : in STD_LOGIC_VECTOR(4 DOWNTO 0) ;
h : buffer STD_LOGIC_VECTOR(30 DOWNTO 0) ;
x1,xb : in STD_LOGIC_VECTOR(27 DOWNTO 0)) ;
end Booth_decoder ;

architecture Behavioral of Booth_decoder  is
signal k :  STD_LOGIC_VECTOR(30 DOWNTO 0) ;
signal j :  STD_LOGIC_VECTOR(30 DOWNTO 0) ;
signal l :  STD_LOGIC_VECTOR(4 DOWNTO 0) ;
signal cr6    :  STD_LOGIC;
component Sub_Adder is
Port ( x : in STD_LOGIC_VECTOR (30 downto 0);
   y : in STD_LOGIC_VECTOR (30 downto 0);
   Cin : in STD_LOGIC;
   S : out STD_LOGIC_VECTOR (30 downto 0);
   Cout : out STD_LOGIC) ;
end component;
begin
process(c)
 begin
  case c(2 downto 0) is
		when "000" => j <= "0000000000000000000000000000000";  
		when "001" => if (x1(27)='1') then j  <= "111" & x1; else j <= "000" & x1; end if;
		when "010" => if (x1(27)='1') then j  <= "111" & x1; else j <= "000" & x1; end if;
		when "011" => if (x1(27)='1') then j  <= "11" & x1 & '0'; else j <= "00" & x1 & '0'; end if;
		when "100" => if (xb(27)='1') then j  <= "11" & xb & '0'; else j <= "00" & xb & '0'; end if;
		when "101" => if (xb(27)='1') then j  <= "111" & xb; else j <= "000" & xb; end if;
		when "110" => if (xb(27)='1') then j  <= "111" & xb; else j <= "000" & xb; end if;
		when "111" => j <= "0000000000000000000000000000000";
  end case;

  case c(4 downto 2) is
		when "000" => k <= "0000000000000000000000000000000"; 
		when "001" => if (x1(27)='1') then k  <= '1' & x1 & "00"; else k <= '0' & x1 & "00"; end if;
		when "010" => if (x1(27)='1') then k  <= '1' & x1 & "00"; else k <= '0' & x1 & "00"; end if;
		when "011" => if (x1(27)='1') then k  <=  x1 & "000"; else k <=   x1 & "000"; end if;
		when "100" => if (xb(27)='1') then k  <=  xb & "000"; else k <=  xb & "000"; end if;
		when "101" => if (xb(27)='1') then k  <= '1' & xb & "00"; else k <= '0' & xb & "00"; end if; 
		when "110" => if (xb(27)='1') then k  <= '1' & xb & "00"; else k <= '0' & xb & "00"; end if; 
		when "111" => k <= "0000000000000000000000000000000";
  end case;
end process;

A7: Sub_Adder port map (j,k,'0',h,cr6);

end Behavioral;
-------------------------------------------------------------
-- RCA --
library ieee;
use ieee.std_logic_1164.all;
use ieee.NUMERIC_STD.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_signed.all;
entity RCA is
Port ( in1,in2 : in STD_LOGIC_VECTOR(8 DOWNTO 0) ;
out1 : buffer STD_LOGIC_VECTOR(8 DOWNTO 0) );
end RCA ;
architecture Behavioral of RCA  is
signal carry:  STD_LOGIC_VECTOR(9 DOWNTO 0);
begin
carry(0) <='0';
G1: for m in 0 to 8 generate
out1(m) <= in1(m) xor in2(m) xor carry(m);
carry(m+1) <= (in1(m) and in2(m)) or (in2(m) and carry(m)) or (in1(m) and carry(m));
end generate G1;
end Behavioral;